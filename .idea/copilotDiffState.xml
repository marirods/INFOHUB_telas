<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infohub_telas/telas/TelaLocalizacao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infohub_telas/telas/TelaLocalizacao.kt" />
              <option name="originalContent" value="package com.example.infohub_telas.telas&#10;&#10;import android.location.Address&#10;import android.location.Geocoder&#10;import android.util.Log&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.interaction.MutableInteractionSource&#10;import androidx.compose.foundation.interaction.collectIsHoveredAsState&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.draw.scale&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalInspectionMode&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import androidx.navigation.NavController&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.infohub_telas.R&#10;import com.example.infohub_telas.components.AnimatedScrollableBottomMenu&#10;import com.example.infohub_telas.components.rememberMenuVisibility&#10;import androidx.compose.foundation.rememberScrollState&#10;import com.example.infohub_telas.service.RetrofitFactory&#10;import com.example.infohub_telas.ui.theme.InfoHub_telasTheme&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import org.osmdroid.util.GeoPoint&#10;import org.osmdroid.views.overlay.Marker&#10;import org.osmdroid.views.MapView&#10;import org.osmdroid.tileprovider.tilesource.TileSourceFactory&#10;import org.osmdroid.config.Configuration&#10;import java.io.IOException&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;import java.net.URLEncoder&#10;import android.graphics.Bitmap&#10;import android.graphics.Canvas&#10;import android.graphics.Paint&#10;import android.graphics.drawable.BitmapDrawable&#10;import android.content.Context&#10;&#10;&#10;// Função para criar alfinete vermelho&#10;fun criarIconeAlfinete(context: Context): BitmapDrawable {&#10;    val size = 90&#10;    val bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888)&#10;    val canvas = Canvas(bitmap)&#10;    &#10;    val paint = Paint().apply {&#10;        color = android.graphics.Color.parseColor(&quot;#D32F2F&quot;)&#10;        isAntiAlias = true&#10;        style = Paint.Style.FILL&#10;    }&#10;    &#10;&#10;    val path = android.graphics.Path()&#10;    val centerX = size / 2f&#10;    val topY = size * 0.15f&#10;    val bottomY = size * 0.85f&#10;    val radius = size * 0.25f&#10;    &#10;&#10;    path.addCircle(centerX, topY + radius, radius, android.graphics.Path.Direction.CW)&#10;    &#10;    // Triângulo inferior&#10;    path.moveTo(centerX - radius * 0.7f, topY + radius * 1.5f)&#10;    path.lineTo(centerX, bottomY)&#10;    path.lineTo(centerX + radius * 0.7f, topY + radius * 1.5f)&#10;    path.close()&#10;    &#10;    canvas.drawPath(path, paint)&#10;    &#10;    // Desenha círculo branco interno&#10;    val paintInterno = Paint().apply {&#10;        color = android.graphics.Color.WHITE&#10;        isAntiAlias = true&#10;        style = Paint.Style.FILL&#10;    }&#10;    canvas.drawCircle(centerX, topY + radius, radius * 0.4f, paintInterno)&#10;    &#10;    return BitmapDrawable(context.resources, bitmap)&#10;}&#10;&#10;// Função para ícone de carrinho branco com círculo laranja&#10;fun criarIconeCarrinho(context: Context): BitmapDrawable {&#10;    val size = 70&#10;    val bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888)&#10;    val canvas = Canvas(bitmap)&#10;    &#10;    // Desenha círculo de fundo laranja claro&#10;    val paintFundo = Paint().apply {&#10;        color = android.graphics.Color.parseColor(&quot;#FFB74D&quot;)&#10;        isAntiAlias = true&#10;        style = Paint.Style.FILL&#10;    }&#10;    canvas.drawCircle(size / 2f, size / 2f, size / 2.5f, paintFundo)&#10;    &#10;&#10;    val paintBorda = Paint().apply {&#10;        color = android.graphics.Color.WHITE&#10;        isAntiAlias = true&#10;        style = Paint.Style.STROKE&#10;        strokeWidth = 4f&#10;    }&#10;    canvas.drawCircle(size / 2f, size / 2f, size / 2.5f, paintBorda)&#10;    &#10;&#10;    val paintTexto = Paint().apply {&#10;        color = android.graphics.Color.WHITE // Carrinho branco&#10;        textSize = 35f&#10;        textAlign = Paint.Align.CENTER&#10;        isAntiAlias = true&#10;    }&#10;    &#10;    val xPos = size / 2f&#10;    val yPos = (size / 2f) - ((paintTexto.descent() + paintTexto.ascent()) / 2)&#10;    canvas.drawText(&quot;&quot;, xPos, yPos, paintTexto)&#10;    &#10;    return BitmapDrawable(context.resources, bitmap)&#10;}&#10;&#10;data class Estabelecimento(&#10;    val nome: String,&#10;    val tipo: String,&#10;    val localizacao: GeoPoint,&#10;    var distancia: Double = 0.0,&#10;    val endereco: String = &quot;&quot;,&#10;    val numero: String = &quot;&quot;,&#10;    val bairro: String = &quot;&quot;,&#10;    val rating: Float = 0f,&#10;    val totalReviews: Int = 0,&#10;    val photoUrl: String = &quot;&quot;,&#10;    val comentarios: List&lt;String&gt; = emptyList()&#10;)&#10;&#10;// Calcular distância entre dois pontos (em km)&#10;fun calcularDistancia(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {&#10;    val R = 6371.0 // Raio da Terra em km&#10;    val dLat = Math.toRadians(lat2 - lat1)&#10;    val dLon = Math.toRadians(lon2 - lon1)&#10;    val a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +&#10;            Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *&#10;            Math.sin(dLon / 2) * Math.sin(dLon / 2)&#10;    val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))&#10;    return R * c&#10;}&#10;&#10;&#10;suspend fun buscarMercadosProximos(lat: Double, lon: Double, raioKm: Double = 2.0):&#10;        List&lt;Estabelecimento&gt; = withContext(Dispatchers.IO) {&#10;    val estabelecimentos = mutableListOf&lt;Estabelecimento&gt;()&#10;    var conn: HttpURLConnection? = null&#10;    try {&#10;&#10;        val raioMetros = (raioKm * 1000).toInt()&#10;        &#10;        val overpassQuery = &quot;&quot;&quot;&#10;            [out:json][timeout:25];&#10;            (&#10;              node[&quot;shop&quot;=&quot;supermarket&quot;](around:$raioMetros,$lat,$lon);&#10;              way[&quot;shop&quot;=&quot;supermarket&quot;](around:$raioMetros,$lat,$lon);&#10;              node[&quot;shop&quot;=&quot;convenience&quot;](around:$raioMetros,$lat,$lon);&#10;              way[&quot;shop&quot;=&quot;convenience&quot;](around:$raioMetros,$lat,$lon);&#10;              node[&quot;shop&quot;=&quot;grocery&quot;](around:$raioMetros,$lat,$lon);&#10;              way[&quot;shop&quot;=&quot;grocery&quot;](around:$raioMetros,$lat,$lon);&#10;            );&#10;            out center;&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        val encodedQuery = URLEncoder.encode(overpassQuery, &quot;UTF-8&quot;)&#10;        val urlStr = &quot;https://overpass-api.de/api/interpreter?data=$encodedQuery&quot;&#10;&#10;        Log.d(&quot;OVERPASS_DEBUG&quot;, &quot;Buscando estabelecimentos próximos em raio de $raioKm km&quot;)&#10;&#10;        val url = URL(urlStr)&#10;        conn = url.openConnection() as HttpURLConnection&#10;        conn.requestMethod = &quot;GET&quot;&#10;        conn.setRequestProperty(&quot;User-Agent&quot;, &quot;InfoHubApp/1.0&quot;)&#10;        conn.connectTimeout = 25000&#10;        conn.readTimeout = 25000&#10;        conn.connect()&#10;&#10;        if (conn.responseCode == HttpURLConnection.HTTP_OK) {&#10;            conn.inputStream.bufferedReader().use {&#10;                val response = it.readText()&#10;                Log.d(&quot;OVERPASS_DEBUG&quot;, &quot;Resposta recebida com sucesso&quot;)&#10;                &#10;                val jsonObject = org.json.JSONObject(response)&#10;                val elements = jsonObject.getJSONArray(&quot;elements&quot;)&#10;&#10;                for (i in 0 until elements.length()) {&#10;                    val element = elements.getJSONObject(i)&#10;                    val tags = element.optJSONObject(&quot;tags&quot;)&#10;                    &#10;                    if (tags != null) {&#10;                        val nome = tags.optString(&quot;name&quot;, &quot;Estabelecimento sem nome&quot;)&#10;                        val shopType = tags.optString(&quot;shop&quot;, &quot;desconhecido&quot;)&#10;                        &#10;                        val tipo = when (shopType) {&#10;                            &quot;supermarket&quot; -&gt; &quot;Supermercado&quot;&#10;                            &quot;convenience&quot; -&gt; &quot;Mercado&quot;&#10;                            &quot;grocery&quot; -&gt; &quot;Mercearia&quot;&#10;                            else -&gt; &quot;Comércio&quot;&#10;                        }&#10;                        &#10;&#10;                        val latEstab: Double&#10;                        val lonEstab: Double&#10;                        &#10;                        if (element.has(&quot;lat&quot;) &amp;&amp; element.has(&quot;lon&quot;)) {&#10;&#10;                            latEstab = element.getDouble(&quot;lat&quot;)&#10;                            lonEstab = element.getDouble(&quot;lon&quot;)&#10;                        } else if (element.has(&quot;center&quot;)) {&#10;&#10;                            val center = element.getJSONObject(&quot;center&quot;)&#10;                            latEstab = center.getDouble(&quot;lat&quot;)&#10;                            lonEstab = center.getDouble(&quot;lon&quot;)&#10;                        } else {&#10;                            continue&#10;                        }&#10;                        &#10;&#10;                        val street = tags.optString(&quot;addr:street&quot;, &quot;Rua não informada&quot;)&#10;                        val houseNumber = tags.optString(&quot;addr:housenumber&quot;, &quot;S/N&quot;)&#10;                        val suburb = tags.optString(&quot;addr:suburb&quot;, tags.optString(&quot;addr:neighbourhood&quot;, &quot;Bairro não informado&quot;))&#10;                        val city = tags.optString(&quot;addr:city&quot;, &quot;São Paulo&quot;)&#10;                        &#10;                        val enderecoCompleto = &quot;$street, $houseNumber - $suburb, $city&quot;&#10;&#10;                        val photoSeed = (latEstab * 1000 + lonEstab * 1000).toInt().toString()&#10;                        val photoUrl = when (shopType) {&#10;                            &quot;supermarket&quot; -&gt; &quot;https://source.unsplash.com/400x300/?supermarket,grocery&amp;sig=$photoSeed&quot;&#10;                            &quot;convenience&quot; -&gt; &quot;https://source.unsplash.com/400x300/?convenience,store&amp;sig=$photoSeed&quot;&#10;                            &quot;grocery&quot; -&gt; &quot;https://source.unsplash.com/400x300/?market,food&amp;sig=$photoSeed&quot;&#10;                            else -&gt; &quot;https://source.unsplash.com/400x300/?shop,store&amp;sig=$photoSeed&quot;&#10;                        }&#10;                        &#10;&#10;                        val comentariosPossiveis = listOf(&#10;                            &quot;Ótimo atendimento!&quot;,&#10;                            &quot;Preços justos e produtos frescos&quot;,&#10;                            &quot;Sempre encontro o que preciso&quot;,&#10;                            &quot;Ambiente limpo e organizado&quot;,&#10;                            &quot;Variedade de produtos&quot;,&#10;                            &quot;Bom custo-benefício&quot;,&#10;                            &quot;Atendimento rápido&quot;,&#10;                            &quot;Produtos de qualidade&quot;&#10;                        )&#10;                        val numComentarios = (1..3).random()&#10;                        val comentarios = comentariosPossiveis.shuffled().take(numComentarios)&#10;                        &#10;                        estabelecimentos.add(&#10;                            Estabelecimento(&#10;                                nome = nome,&#10;                                tipo = tipo,&#10;                                localizacao = GeoPoint(latEstab, lonEstab),&#10;                                endereco = street,&#10;                                numero = houseNumber,&#10;                                bairro = suburb,&#10;                                rating = (3.5f + Math.random().toFloat() * 1.5f).coerceIn(0f, 5f),&#10;                                totalReviews = (10..500).random(),&#10;                                photoUrl = photoUrl,&#10;                                comentarios = comentarios&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                Log.d(&quot;OVERPASS_DEBUG&quot;, &quot;${estabelecimentos.size} estabelecimentos encontrados&quot;)&#10;            }&#10;        } else {&#10;            Log.e(&quot;OVERPASS_ERROR&quot;, &quot;Erro na requisição: ${conn.responseCode} ${conn.responseMessage}&quot;)&#10;        }&#10;    } catch (e: Exception) {&#10;        Log.e(&quot;OVERPASS_ERROR&quot;, &quot;Erro ao buscar estabelecimentos: ${e.message}&quot;, e)&#10;    } finally {&#10;        conn?.disconnect()&#10;    }&#10;    return@withContext estabelecimentos&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun TelaLocalizacao(navController: NavController) {&#10;&#10;    val isPreview = LocalInspectionMode.current&#10;    val context = LocalContext.current&#10;    val prefs = context.getSharedPreferences(&quot;auth&quot;, android.content.Context.MODE_PRIVATE)&#10;    val isAdmin = prefs.getBoolean(&quot;isAdmin&quot;, false)&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Estado para controlar rolagem e visibilidade do menu&#10;    val scrollState = rememberScrollState()&#10;    val isMenuVisible = scrollState.rememberMenuVisibility()&#10;&#10;    var cep by remember { mutableStateOf(&quot;&quot;) }&#10;    var endereco by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var feedbackMessage by remember { mutableStateOf&lt;Pair&lt;String, Color&gt;?&gt;(null) }&#10;    var estabelecimentosEncontrados by remember { mutableStateOf&lt;List&lt;Estabelecimento&gt;&gt;(emptyList()) }&#10;    var localizacaoUsuario by remember { mutableStateOf&lt;GeoPoint?&gt;(null) }&#10;    var estabelecimentoSelecionado by remember { mutableStateOf&lt;Estabelecimento?&gt;(null) }&#10;&#10;    val mapView = if (!isPreview) {&#10;        remember {&#10;            org.osmdroid.views.MapView(context).apply {&#10;                setTileSource(org.osmdroid.tileprovider.tilesource.TileSourceFactory.MAPNIK)&#10;                setMultiTouchControls(true)&#10;                controller.setZoom(15.0)&#10;                controller.setCenter(GeoPoint(-23.55052, -46.633308)) // São Paulo&#10;            }&#10;        }&#10;    } else null&#10;&#10;&#10;    DisposableEffect(mapView) {&#10;        onDispose {&#10;            mapView?.overlays?.clear()&#10;            mapView?.invalidate()&#10;        }&#10;    }&#10;&#10;    // Box externo para conter todos os composables da tela&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Box principal com conteúdo&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.White)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .verticalScroll(scrollState),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            // Cabeçalho da tela&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .background(Color(0xFFF9A01B))&#10;                    .padding(16.dp),&#10;                contentAlignment = Alignment.CenterStart&#10;            ) {&#10;                Text(&#10;                    text = &quot;Localização de Estabelecimentos&quot;,&#10;                    fontSize = 20.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color.White&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            if (!isPreview) {&#10;                Card(&#10;                    shape = RoundedCornerShape(16.dp),&#10;                    elevation = CardDefaults.cardElevation(6.dp),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth(0.9f)&#10;                        .height(300.dp)&#10;                ) {&#10;                    AndroidView(factory = { mapView!! }, modifier = Modifier.fillMaxSize())&#10;                }&#10;            } else {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth(0.9f)&#10;                        .height(300.dp)&#10;                        .background(Color.LightGray),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&quot;Mapa (Preview)&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier&#10;                .height(16.dp))&#10;&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth(),&#10;                horizontalAlignment = Alignment.CenterHorizontally) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth(0.9f)&#10;                        .background(Color.White, RoundedCornerShape(16.dp))&#10;                        .padding(12.dp),&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    TextField(&#10;                        value = cep,&#10;                        onValueChange = {&#10;                            cep = it&#10;                            feedbackMessage = null&#10;                        },&#10;                        placeholder = { Text(&quot;Digite um endereço ou CEP (ex: 01310-100...)&quot;) },&#10;                        singleLine = true,&#10;                        modifier = Modifier.weight(1f),&#10;                        colors = TextFieldDefaults.colors(&#10;                            unfocusedContainerColor = Color(0xFFF5F5F5),&#10;                            focusedContainerColor = Color(0xFFEEEEEE)&#10;                        )&#10;                    )&#10;                    IconButton(onClick = {&#10;                        scope.launch {&#10;                            try {&#10;                                val input = cep.trim()&#10;                                var enderecoResult: String? = null&#10;&#10;                                if (input.matches(Regex(&quot;\\d{5}-?\\d{3}&quot;))) {&#10;                                    val viaCepService = RetrofitFactory().getViaCepService()&#10;                                    val resposta = viaCepService.buscarCep(input)&#10;                                    enderecoResult = &quot;${resposta.logradouro}, ${resposta.bairro}, ${resposta.localidade} - ${resposta.uf}&quot;&#10;                                } else {&#10;                                    enderecoResult = input&#10;                                }&#10;&#10;                                if (isPreview) {&#10;                                    endereco = enderecoResult&#10;                                    feedbackMessage = &quot;Endereço encontrado com sucesso!&quot; to Color(0xFF006400)&#10;                                    return@launch&#10;                                }&#10;&#10;                                val geo: List&lt;Address&gt;? = withContext(Dispatchers.IO) {&#10;                                    try {&#10;                                        Geocoder(context).getFromLocationName(enderecoResult, 1)&#10;                                    } catch (e: IOException) {&#10;                                        Log.e(&quot;GEOCODER_ERROR&quot;, &quot;Erro no Geocoder: ${e.message}&quot;)&#10;                                        null&#10;                                    }&#10;                                }&#10;&#10;                                if (!geo.isNullOrEmpty()) {&#10;                                    val loc = geo[0]&#10;                                    val lat = loc.latitude&#10;                                    val lon = loc.longitude&#10;                                    val userPoint = GeoPoint(lat, lon)&#10;&#10;                                    mapView!!.controller.animateTo(userPoint)&#10;                                    mapView.overlays.clear()&#10;&#10;                                    // Salva localização do usuário&#10;                                    localizacaoUsuario = userPoint&#10;                                    &#10;                                    // Marcador com alfinete vermelho para o usuário&#10;                                    val userMarker = Marker(mapView)&#10;                                    userMarker.position = userPoint&#10;                                    userMarker.setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM)&#10;                                    userMarker.title = &quot; Você está aqui&quot;&#10;                                    userMarker.snippet = enderecoResult&#10;                                    userMarker.icon = criarIconeAlfinete(context)&#10;                                    mapView.overlays.add(userMarker)&#10;&#10;&#10;                                    val estabelecimentos = buscarMercadosProximos(lat, lon, raioKm = 5.0)&#10;                                    if (estabelecimentos.isNotEmpty()) {&#10;                                        Log.d(&quot;OVERPASS_DEBUG&quot;, &quot;${estabelecimentos.size} estabelecimentos encontrados&quot;)&#10;                                        &#10;&#10;                                        estabelecimentos.forEach { estab -&gt;&#10;                                            estab.distancia = calcularDistancia(&#10;                                                lat, lon,&#10;                                                estab.localizacao.latitude,&#10;                                                estab.localizacao.longitude&#10;                                            )&#10;                                        }&#10;                                        val estabelecimentosOrdenados = estabelecimentos.sortedBy { it.distancia }&#10;                                        estabelecimentosEncontrados = estabelecimentosOrdenados&#10;                                        &#10;                                        for (estab in estabelecimentosOrdenados) {&#10;                                            val markerEstab = Marker(mapView)&#10;                                            markerEstab.position = estab.localizacao&#10;                                            markerEstab.title = &quot;${estab.tipo}: ${estab.nome}&quot;&#10;                                            markerEstab.snippet = &quot;Distância: %.2f km&quot;.format(estab.distancia)&#10;                                            markerEstab.setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM)&#10;                                            markerEstab.icon = criarIconeCarrinho(context)&#10;                                            mapView.overlays.add(markerEstab)&#10;                                        }&#10;                                        feedbackMessage = &quot;${estabelecimentos.size} estabelecimentos encontrados!&quot; to Color(0xFF006400)&#10;                                    } else {&#10;                                        Log.d(&quot;OVERPASS_DEBUG&quot;, &quot;Nenhum estabelecimento encontrado nas proximidades.&quot;)&#10;                                        estabelecimentosEncontrados = emptyList()&#10;                                        feedbackMessage = &quot;Endereço encontrado, mas nenhum estabelecimento próximo.&quot; to Color(0xFFFFA500)&#10;                                    }&#10;&#10;                                    mapView.invalidate()&#10;                                    endereco = enderecoResult&#10;                                } else {&#10;                                    throw Exception(&quot;Endereço não localizado no mapa.&quot;)&#10;                                }&#10;&#10;                            } catch (e: Exception) {&#10;                                Log.e(&quot;SEARCH_ERROR&quot;, &quot;Falha na busca: ${e.message}&quot;, e)&#10;                                endereco = null&#10;                                feedbackMessage = &quot;Endereço não encontrado. Tente novamente.&quot; to Color.Red&#10;                            }&#10;                        }&#10;                    }) {&#10;                        Image(&#10;                            painter = painterResource(id = R.drawable.lupa_loc),&#10;                            contentDescription = &quot;Buscar&quot;,&#10;                            modifier = Modifier.size(24.dp)&#10;                        )&#10;                    }&#10;                    Image(&#10;                        painter = painterResource(id = R.drawable.microfone_loc),&#10;                        contentDescription = &quot;Microfone&quot;,&#10;                        modifier = Modifier.size(24.dp)&#10;                    )&#10;                }&#10;&#10;                feedbackMessage?.let { (message, color) -&gt;&#10;                    Text(&#10;                        text = message,&#10;                        modifier = Modifier.padding(top = 8.dp),&#10;                        fontSize = 14.sp,&#10;                        color = color&#10;                    )&#10;                }&#10;                &#10;&#10;                if (estabelecimentosEncontrados.isNotEmpty()) {&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    Column(&#10;                        modifier = Modifier.fillMaxWidth(0.9f),&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        estabelecimentosEncontrados.forEach { estab -&gt;&#10;                            val interactionSource = remember { MutableInteractionSource() }&#10;                            val isHovered by interactionSource.collectIsHoveredAsState()&#10;                            val scale by animateFloatAsState(&#10;                                targetValue = if (isHovered) 1.05f else 1f,&#10;                                label = &quot;card_scale&quot;&#10;                            )&#10;                            &#10;                            // Animação de clique&#10;                            val clickScale = remember { Animatable(1f) }&#10;                            val coroutineScope = rememberCoroutineScope()&#10;                            &#10;                            Card(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .scale(scale * clickScale.value)&#10;                                    .clickable(interactionSource = interactionSource, indication = null) {&#10;                                        coroutineScope.launch {&#10;                                            // Animação de &quot;pulse&quot; ao clicar&#10;                                            clickScale.animateTo(&#10;                                                targetValue = 0.95f,&#10;                                                animationSpec = tween(durationMillis = 100)&#10;                                            )&#10;                                            clickScale.animateTo(&#10;                                                targetValue = 1.05f,&#10;                                                animationSpec = tween(durationMillis = 100)&#10;                                            )&#10;                                            clickScale.animateTo(&#10;                                                targetValue = 1f,&#10;                                                animationSpec = tween(durationMillis = 100)&#10;                                            )&#10;                                            // Abre o modal após a animação&#10;                                            estabelecimentoSelecionado = estab&#10;                                        }&#10;                                    },&#10;                                shape = RoundedCornerShape(12.dp),&#10;                                colors = CardDefaults.cardColors(containerColor = Color.White),&#10;                                elevation = CardDefaults.cardElevation(4.dp)&#10;                            ) {&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(12.dp)&#10;                                ) {&#10;                                    Row(&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        // Foto do estabelecimento&#10;                                        AsyncImage(&#10;                                            model = ImageRequest.Builder(LocalContext.current)&#10;                                                .data(estab.photoUrl)&#10;                                                .crossfade(true)&#10;                                                .build(),&#10;                                            contentDescription = &quot;Foto de ${estab.nome}&quot;,&#10;                                            modifier = Modifier&#10;                                                .size(60.dp)&#10;                                                .background(Color(0xFFE0E0E0), RoundedCornerShape(8.dp)),&#10;                                            contentScale = ContentScale.Crop&#10;                                        )&#10;                                        &#10;                                        Spacer(modifier = Modifier.width(12.dp))&#10;                                        &#10;                                        Column(modifier = Modifier.weight(1f)) {&#10;                                            Text(&#10;                                                text = estab.nome,&#10;                                                fontSize = 14.sp,&#10;                                                color = Color.Black,&#10;                                                maxLines = 1,&#10;                                                style = TextStyle(fontWeight = FontWeight.Bold)&#10;                                            )&#10;                                            Text(&#10;                                                text = estab.tipo,&#10;                                                fontSize = 12.sp,&#10;                                                color = Color.Gray&#10;                                            )&#10;&#10;                                            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                                                repeat(5) { index -&gt;&#10;                                                    Text(&#10;                                                        text = if (index &lt; estab.rating.toInt()) &quot;⭐&quot; else &quot;☆&quot;,&#10;                                                        fontSize = 10.sp,&#10;                                                        color = if (index &lt; estab.rating.toInt()) Color(0xFFFFC107) else Color.Gray&#10;                                                    )&#10;                                                }&#10;                                                Text(&#10;                                                    text = &quot; %.1f&quot;.format(estab.rating),&#10;                                                    fontSize = 11.sp,&#10;                                                    color = Color.Gray&#10;                                                )&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                    &#10;&#10;                                    if (estab.comentarios.isNotEmpty()) {&#10;                                        Spacer(modifier = Modifier.height(8.dp))&#10;                                        Card(&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            colors = CardDefaults.cardColors(containerColor = Color(0xFFF5F5F5)),&#10;                                            shape = RoundedCornerShape(8.dp)&#10;                                        ) {&#10;                                            Column(modifier = Modifier.padding(8.dp)) {&#10;                                                Text(&#10;                                                    text = &quot; Comentários:&quot;,&#10;                                                    fontSize = 11.sp,&#10;                                                    color = Color.Gray,&#10;                                                    style = TextStyle(fontWeight = FontWeight.Bold)&#10;                                                )&#10;                                                Spacer(modifier = Modifier.height(4.dp))&#10;                                                estab.comentarios.take(2).forEach { comentario -&gt;&#10;                                                    Text(&#10;                                                        text = &quot;• $comentario&quot;,&#10;                                                        fontSize = 11.sp,&#10;                                                        color = Color.DarkGray,&#10;                                                        maxLines = 1&#10;                                                    )&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                }&#10;                }&#10;            }&#10;        }&#10;        } // Fecha o Box principal&#10;&#10;        // Menu inferior animado - dentro do Box externo&#10;        AnimatedScrollableBottomMenu(&#10;            navController = navController,&#10;            isAdmin = isAdmin,&#10;            isVisible = isMenuVisible&#10;        )&#10;&#10;        estabelecimentoSelecionado?.let { estab -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.Black.copy(alpha = 0.5f))&#10;                .clickable { estabelecimentoSelecionado = null },&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth(0.9f)&#10;                    .padding(16.dp)&#10;                    .clickable(enabled = false) { },&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = Color.White),&#10;                elevation = CardDefaults.cardElevation(8.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .padding(16.dp)&#10;                ) {&#10;&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = estab.tipo,&#10;                            fontSize = 14.sp,&#10;                            color = Color.Gray&#10;                        )&#10;                        IconButton(onClick = { estabelecimentoSelecionado = null }) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Close,&#10;                                contentDescription = &quot;Fechar&quot;,&#10;                                tint = Color.Gray&#10;                            )&#10;                        }&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    &#10;&#10;                    if (estab.photoUrl.isNotEmpty()) {&#10;                        AsyncImage(&#10;                            model = ImageRequest.Builder(LocalContext.current)&#10;                                .data(estab.photoUrl)&#10;                                .crossfade(true)&#10;                                .build(),&#10;                            contentDescription = &quot;Foto de ${estab.nome}&quot;,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(180.dp)&#10;                                .background(Color(0xFFE0E0E0), RoundedCornerShape(12.dp)),&#10;                            contentScale = ContentScale.Crop&#10;                        )&#10;                    } else {&#10;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(180.dp)&#10;                                .background(Color(0xFFE0E0E0), RoundedCornerShape(12.dp)),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            val emoji = when (estab.tipo) {&#10;                                &quot;Supermercado&quot; -&gt; &quot;&quot;&#10;                                &quot;Mercado&quot; -&gt; &quot;&quot;&#10;                                &quot;Mercearia&quot; -&gt; &quot;&quot;&#10;                                else -&gt; &quot;&quot;&#10;                            }&#10;                            Text(&#10;                                text = emoji,&#10;                                fontSize = 80.sp&#10;                            )&#10;                        }&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    &#10;                    // Nome do estabelecimento&#10;                    Text(&#10;                        text = estab.nome,&#10;                        fontSize = 20.sp,&#10;                        color = Color.Black&#10;                    )&#10;                    &#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    &#10;                    // Avaliação&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        repeat(5) { index -&gt;&#10;                            Icon(&#10;                                imageVector = Icons.Default.Star,&#10;                                contentDescription = &quot;Estrela&quot;,&#10;                                tint = if (index &lt; estab.rating) Color(0xFFFFC107) else Color(0xFFE0E0E0),&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(&#10;                            text = &quot;%.1f&quot;.format(estab.rating),&#10;                            fontSize = 16.sp,&#10;                            color = Color.Black,&#10;                            style = TextStyle(fontWeight = FontWeight.Bold)&#10;                        )&#10;                        Text(&#10;                            text = &quot; (${estab.totalReviews} avaliações)&quot;,&#10;                            fontSize = 13.sp,&#10;                            color = Color.Gray&#10;                        )&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    &#10;                    // Endereço Completo&#10;                    Row(&#10;                        verticalAlignment = Alignment.Top&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;&quot;,&#10;                            fontSize = 20.sp,&#10;                            modifier = Modifier.padding(end = 8.dp)&#10;                        )&#10;                        Column {&#10;                            Text(&#10;                                text = &quot;Endereço Completo&quot;,&#10;                                fontSize = 12.sp,&#10;                                color = Color.Gray&#10;                            )&#10;                            Text(&#10;                                text = &quot;${estab.endereco}, ${estab.numero}&quot;,&#10;                                fontSize = 14.sp,&#10;                                color = Color.Black,&#10;                                style = TextStyle(fontWeight = FontWeight.Bold)&#10;                            )&#10;                            Text(&#10;                                text = estab.bairro,&#10;                                fontSize = 13.sp,&#10;                                color = Color.DarkGray&#10;                            )&#10;                        }&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(12.dp))&#10;                    &#10;                    // Distância&#10;                    Row(&#10;                        verticalAlignment = Alignment.Top&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;&quot;,&#10;                            fontSize = 20.sp,&#10;                            modifier = Modifier.padding(end = 8.dp)&#10;                        )&#10;                        Column {&#10;                            Text(&#10;                                text = &quot;Distância&quot;,&#10;                                fontSize = 12.sp,&#10;                                color = Color.Gray&#10;                            )&#10;                            Text(&#10;                                text = &quot;%.2f km de você&quot;.format(estab.distancia),&#10;                                fontSize = 14.sp,&#10;                                color = Color(0xFFF9A01B)&#10;                            )&#10;                        }&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    &#10;                    // Botão de ação&#10;                    Button(&#10;                        onClick = {  },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth(),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFFF9A01B)&#10;                        )&#10;                    ) {&#10;                        Text(&quot;Ver no Mapa&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        } // Fecha o estabelecimentoSelecionado?.let&#10;    } // Fecha o Box externo&#10;} // Fecha a função TelaLocalizacao&#10;&#10;&#10;// Preview da tela de localização&#10;@Preview(showSystemUi = true)&#10;@Composable&#10;fun TelaLocalizacaoPreview() {&#10;    InfoHub_telasTheme {&#10;        TelaLocalizacao(rememberNavController())&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.infohub_telas.telas&#10;&#10;import android.location.Address&#10;import android.location.Geocoder&#10;import android.util.Log&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.interaction.MutableInteractionSource&#10;import androidx.compose.foundation.interaction.collectIsHoveredAsState&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.draw.scale&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalInspectionMode&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import androidx.navigation.NavController&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.infohub_telas.R&#10;&#10;import androidx.compose.foundation.rememberScrollState&#10;import com.example.infohub_telas.service.RetrofitFactory&#10;import com.example.infohub_telas.ui.theme.InfoHub_telasTheme&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import org.osmdroid.util.GeoPoint&#10;import org.osmdroid.views.overlay.Marker&#10;import org.osmdroid.views.MapView&#10;import org.osmdroid.tileprovider.tilesource.TileSourceFactory&#10;import org.osmdroid.config.Configuration&#10;import java.io.IOException&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;import java.net.URLEncoder&#10;import android.graphics.Bitmap&#10;import android.graphics.Canvas&#10;import android.graphics.Paint&#10;import android.graphics.drawable.BitmapDrawable&#10;import android.content.Context&#10;&#10;&#10;// Função para criar alfinete vermelho&#10;fun criarIconeAlfinete(context: Context): BitmapDrawable {&#10;    val size = 90&#10;    val bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888)&#10;    val canvas = Canvas(bitmap)&#10;    &#10;    val paint = Paint().apply {&#10;        color = android.graphics.Color.parseColor(&quot;#D32F2F&quot;)&#10;        isAntiAlias = true&#10;        style = Paint.Style.FILL&#10;    }&#10;    &#10;&#10;    val path = android.graphics.Path()&#10;    val centerX = size / 2f&#10;    val topY = size * 0.15f&#10;    val bottomY = size * 0.85f&#10;    val radius = size * 0.25f&#10;    &#10;&#10;    path.addCircle(centerX, topY + radius, radius, android.graphics.Path.Direction.CW)&#10;    &#10;    // Triângulo inferior&#10;    path.moveTo(centerX - radius * 0.7f, topY + radius * 1.5f)&#10;    path.lineTo(centerX, bottomY)&#10;    path.lineTo(centerX + radius * 0.7f, topY + radius * 1.5f)&#10;    path.close()&#10;    &#10;    canvas.drawPath(path, paint)&#10;    &#10;    // Desenha círculo branco interno&#10;    val paintInterno = Paint().apply {&#10;        color = android.graphics.Color.WHITE&#10;        isAntiAlias = true&#10;        style = Paint.Style.FILL&#10;    }&#10;    canvas.drawCircle(centerX, topY + radius, radius * 0.4f, paintInterno)&#10;    &#10;    return BitmapDrawable(context.resources, bitmap)&#10;}&#10;&#10;// Função para ícone de carrinho branco com círculo laranja&#10;fun criarIconeCarrinho(context: Context): BitmapDrawable {&#10;    val size = 70&#10;    val bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888)&#10;    val canvas = Canvas(bitmap)&#10;    &#10;    // Desenha círculo de fundo laranja claro&#10;    val paintFundo = Paint().apply {&#10;        color = android.graphics.Color.parseColor(&quot;#FFB74D&quot;)&#10;        isAntiAlias = true&#10;        style = Paint.Style.FILL&#10;    }&#10;    canvas.drawCircle(size / 2f, size / 2f, size / 2.5f, paintFundo)&#10;    &#10;&#10;    val paintBorda = Paint().apply {&#10;        color = android.graphics.Color.WHITE&#10;        isAntiAlias = true&#10;        style = Paint.Style.STROKE&#10;        strokeWidth = 4f&#10;    }&#10;    canvas.drawCircle(size / 2f, size / 2f, size / 2.5f, paintBorda)&#10;    &#10;&#10;    val paintTexto = Paint().apply {&#10;        color = android.graphics.Color.WHITE // Carrinho branco&#10;        textSize = 35f&#10;        textAlign = Paint.Align.CENTER&#10;        isAntiAlias = true&#10;    }&#10;    &#10;    val xPos = size / 2f&#10;    val yPos = (size / 2f) - ((paintTexto.descent() + paintTexto.ascent()) / 2)&#10;    canvas.drawText(&quot;&quot;, xPos, yPos, paintTexto)&#10;    &#10;    return BitmapDrawable(context.resources, bitmap)&#10;}&#10;&#10;data class Estabelecimento(&#10;    val nome: String,&#10;    val tipo: String,&#10;    val localizacao: GeoPoint,&#10;    var distancia: Double = 0.0,&#10;    val endereco: String = &quot;&quot;,&#10;    val numero: String = &quot;&quot;,&#10;    val bairro: String = &quot;&quot;,&#10;    val rating: Float = 0f,&#10;    val totalReviews: Int = 0,&#10;    val photoUrl: String = &quot;&quot;,&#10;    val comentarios: List&lt;String&gt; = emptyList()&#10;)&#10;&#10;// Calcular distância entre dois pontos (em km)&#10;fun calcularDistancia(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {&#10;    val R = 6371.0 // Raio da Terra em km&#10;    val dLat = Math.toRadians(lat2 - lat1)&#10;    val dLon = Math.toRadians(lon2 - lon1)&#10;    val a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +&#10;            Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *&#10;            Math.sin(dLon / 2) * Math.sin(dLon / 2)&#10;    val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))&#10;    return R * c&#10;}&#10;&#10;&#10;suspend fun buscarMercadosProximos(lat: Double, lon: Double, raioKm: Double = 2.0):&#10;        List&lt;Estabelecimento&gt; = withContext(Dispatchers.IO) {&#10;    val estabelecimentos = mutableListOf&lt;Estabelecimento&gt;()&#10;    var conn: HttpURLConnection? = null&#10;    try {&#10;&#10;        val raioMetros = (raioKm * 1000).toInt()&#10;        &#10;        val overpassQuery = &quot;&quot;&quot;&#10;            [out:json][timeout:25];&#10;            (&#10;              node[&quot;shop&quot;=&quot;supermarket&quot;](around:$raioMetros,$lat,$lon);&#10;              way[&quot;shop&quot;=&quot;supermarket&quot;](around:$raioMetros,$lat,$lon);&#10;              node[&quot;shop&quot;=&quot;convenience&quot;](around:$raioMetros,$lat,$lon);&#10;              way[&quot;shop&quot;=&quot;convenience&quot;](around:$raioMetros,$lat,$lon);&#10;              node[&quot;shop&quot;=&quot;grocery&quot;](around:$raioMetros,$lat,$lon);&#10;              way[&quot;shop&quot;=&quot;grocery&quot;](around:$raioMetros,$lat,$lon);&#10;            );&#10;            out center;&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        val encodedQuery = URLEncoder.encode(overpassQuery, &quot;UTF-8&quot;)&#10;        val urlStr = &quot;https://overpass-api.de/api/interpreter?data=$encodedQuery&quot;&#10;&#10;        Log.d(&quot;OVERPASS_DEBUG&quot;, &quot;Buscando estabelecimentos próximos em raio de $raioKm km&quot;)&#10;&#10;        val url = URL(urlStr)&#10;        conn = url.openConnection() as HttpURLConnection&#10;        conn.requestMethod = &quot;GET&quot;&#10;        conn.setRequestProperty(&quot;User-Agent&quot;, &quot;InfoHubApp/1.0&quot;)&#10;        conn.connectTimeout = 25000&#10;        conn.readTimeout = 25000&#10;        conn.connect()&#10;&#10;        if (conn.responseCode == HttpURLConnection.HTTP_OK) {&#10;            conn.inputStream.bufferedReader().use {&#10;                val response = it.readText()&#10;                Log.d(&quot;OVERPASS_DEBUG&quot;, &quot;Resposta recebida com sucesso&quot;)&#10;                &#10;                val jsonObject = org.json.JSONObject(response)&#10;                val elements = jsonObject.getJSONArray(&quot;elements&quot;)&#10;&#10;                for (i in 0 until elements.length()) {&#10;                    val element = elements.getJSONObject(i)&#10;                    val tags = element.optJSONObject(&quot;tags&quot;)&#10;                    &#10;                    if (tags != null) {&#10;                        val nome = tags.optString(&quot;name&quot;, &quot;Estabelecimento sem nome&quot;)&#10;                        val shopType = tags.optString(&quot;shop&quot;, &quot;desconhecido&quot;)&#10;                        &#10;                        val tipo = when (shopType) {&#10;                            &quot;supermarket&quot; -&gt; &quot;Supermercado&quot;&#10;                            &quot;convenience&quot; -&gt; &quot;Mercado&quot;&#10;                            &quot;grocery&quot; -&gt; &quot;Mercearia&quot;&#10;                            else -&gt; &quot;Comércio&quot;&#10;                        }&#10;                        &#10;&#10;                        val latEstab: Double&#10;                        val lonEstab: Double&#10;                        &#10;                        if (element.has(&quot;lat&quot;) &amp;&amp; element.has(&quot;lon&quot;)) {&#10;&#10;                            latEstab = element.getDouble(&quot;lat&quot;)&#10;                            lonEstab = element.getDouble(&quot;lon&quot;)&#10;                        } else if (element.has(&quot;center&quot;)) {&#10;&#10;                            val center = element.getJSONObject(&quot;center&quot;)&#10;                            latEstab = center.getDouble(&quot;lat&quot;)&#10;                            lonEstab = center.getDouble(&quot;lon&quot;)&#10;                        } else {&#10;                            continue&#10;                        }&#10;                        &#10;&#10;                        val street = tags.optString(&quot;addr:street&quot;, &quot;Rua não informada&quot;)&#10;                        val houseNumber = tags.optString(&quot;addr:housenumber&quot;, &quot;S/N&quot;)&#10;                        val suburb = tags.optString(&quot;addr:suburb&quot;, tags.optString(&quot;addr:neighbourhood&quot;, &quot;Bairro não informado&quot;))&#10;                        val city = tags.optString(&quot;addr:city&quot;, &quot;São Paulo&quot;)&#10;                        &#10;                        val enderecoCompleto = &quot;$street, $houseNumber - $suburb, $city&quot;&#10;&#10;                        val photoSeed = (latEstab * 1000 + lonEstab * 1000).toInt().toString()&#10;                        val photoUrl = when (shopType) {&#10;                            &quot;supermarket&quot; -&gt; &quot;https://source.unsplash.com/400x300/?supermarket,grocery&amp;sig=$photoSeed&quot;&#10;                            &quot;convenience&quot; -&gt; &quot;https://source.unsplash.com/400x300/?convenience,store&amp;sig=$photoSeed&quot;&#10;                            &quot;grocery&quot; -&gt; &quot;https://source.unsplash.com/400x300/?market,food&amp;sig=$photoSeed&quot;&#10;                            else -&gt; &quot;https://source.unsplash.com/400x300/?shop,store&amp;sig=$photoSeed&quot;&#10;                        }&#10;                        &#10;&#10;                        val comentariosPossiveis = listOf(&#10;                            &quot;Ótimo atendimento!&quot;,&#10;                            &quot;Preços justos e produtos frescos&quot;,&#10;                            &quot;Sempre encontro o que preciso&quot;,&#10;                            &quot;Ambiente limpo e organizado&quot;,&#10;                            &quot;Variedade de produtos&quot;,&#10;                            &quot;Bom custo-benefício&quot;,&#10;                            &quot;Atendimento rápido&quot;,&#10;                            &quot;Produtos de qualidade&quot;&#10;                        )&#10;                        val numComentarios = (1..3).random()&#10;                        val comentarios = comentariosPossiveis.shuffled().take(numComentarios)&#10;                        &#10;                        estabelecimentos.add(&#10;                            Estabelecimento(&#10;                                nome = nome,&#10;                                tipo = tipo,&#10;                                localizacao = GeoPoint(latEstab, lonEstab),&#10;                                endereco = street,&#10;                                numero = houseNumber,&#10;                                bairro = suburb,&#10;                                rating = (3.5f + Math.random().toFloat() * 1.5f).coerceIn(0f, 5f),&#10;                                totalReviews = (10..500).random(),&#10;                                photoUrl = photoUrl,&#10;                                comentarios = comentarios&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                Log.d(&quot;OVERPASS_DEBUG&quot;, &quot;${estabelecimentos.size} estabelecimentos encontrados&quot;)&#10;            }&#10;        } else {&#10;            Log.e(&quot;OVERPASS_ERROR&quot;, &quot;Erro na requisição: ${conn.responseCode} ${conn.responseMessage}&quot;)&#10;        }&#10;    } catch (e: Exception) {&#10;        Log.e(&quot;OVERPASS_ERROR&quot;, &quot;Erro ao buscar estabelecimentos: ${e.message}&quot;, e)&#10;    } finally {&#10;        conn?.disconnect()&#10;    }&#10;    return@withContext estabelecimentos&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun TelaLocalizacao(navController: NavController) {&#10;&#10;    val isPreview = LocalInspectionMode.current&#10;    val context = LocalContext.current&#10;    val prefs = context.getSharedPreferences(&quot;auth&quot;, android.content.Context.MODE_PRIVATE)&#10;    val isAdmin = prefs.getBoolean(&quot;isAdmin&quot;, false)&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Estado para controlar rolagem&#10;    val scrollState = rememberScrollState()&#10;&#10;    var cep by remember { mutableStateOf(&quot;&quot;) }&#10;    var endereco by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var feedbackMessage by remember { mutableStateOf&lt;Pair&lt;String, Color&gt;?&gt;(null) }&#10;    var estabelecimentosEncontrados by remember { mutableStateOf&lt;List&lt;Estabelecimento&gt;&gt;(emptyList()) }&#10;    var localizacaoUsuario by remember { mutableStateOf&lt;GeoPoint?&gt;(null) }&#10;    var estabelecimentoSelecionado by remember { mutableStateOf&lt;Estabelecimento?&gt;(null) }&#10;&#10;    val mapView = if (!isPreview) {&#10;        remember {&#10;            org.osmdroid.views.MapView(context).apply {&#10;                setTileSource(org.osmdroid.tileprovider.tilesource.TileSourceFactory.MAPNIK)&#10;                setMultiTouchControls(true)&#10;                controller.setZoom(15.0)&#10;                controller.setCenter(GeoPoint(-23.55052, -46.633308)) // São Paulo&#10;            }&#10;        }&#10;    } else null&#10;&#10;&#10;    DisposableEffect(mapView) {&#10;        onDispose {&#10;            mapView?.overlays?.clear()&#10;            mapView?.invalidate()&#10;        }&#10;    }&#10;&#10;    // Box externo para conter todos os composables da tela&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Box principal com conteúdo&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.White)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .verticalScroll(scrollState),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            // Cabeçalho da tela&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .background(Color(0xFFF9A01B))&#10;                    .padding(16.dp),&#10;                contentAlignment = Alignment.CenterStart&#10;            ) {&#10;                Text(&#10;                    text = &quot;Localização de Estabelecimentos&quot;,&#10;                    fontSize = 20.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color.White&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            if (!isPreview) {&#10;                Card(&#10;                    shape = RoundedCornerShape(16.dp),&#10;                    elevation = CardDefaults.cardElevation(6.dp),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth(0.9f)&#10;                        .height(300.dp)&#10;                ) {&#10;                    AndroidView(factory = { mapView!! }, modifier = Modifier.fillMaxSize())&#10;                }&#10;            } else {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth(0.9f)&#10;                        .height(300.dp)&#10;                        .background(Color.LightGray),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&quot;Mapa (Preview)&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier&#10;                .height(16.dp))&#10;&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth(),&#10;                horizontalAlignment = Alignment.CenterHorizontally) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth(0.9f)&#10;                        .background(Color.White, RoundedCornerShape(16.dp))&#10;                        .padding(12.dp),&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    TextField(&#10;                        value = cep,&#10;                        onValueChange = {&#10;                            cep = it&#10;                            feedbackMessage = null&#10;                        },&#10;                        placeholder = { Text(&quot;Digite um endereço ou CEP (ex: 01310-100...)&quot;) },&#10;                        singleLine = true,&#10;                        modifier = Modifier.weight(1f),&#10;                        colors = TextFieldDefaults.colors(&#10;                            unfocusedContainerColor = Color(0xFFF5F5F5),&#10;                            focusedContainerColor = Color(0xFFEEEEEE)&#10;                        )&#10;                    )&#10;                    IconButton(onClick = {&#10;                        scope.launch {&#10;                            try {&#10;                                val input = cep.trim()&#10;                                var enderecoResult: String? = null&#10;&#10;                                if (input.matches(Regex(&quot;\\d{5}-?\\d{3}&quot;))) {&#10;                                    val viaCepService = RetrofitFactory().getViaCepService()&#10;                                    val resposta = viaCepService.buscarCep(input)&#10;                                    enderecoResult = &quot;${resposta.logradouro}, ${resposta.bairro}, ${resposta.localidade} - ${resposta.uf}&quot;&#10;                                } else {&#10;                                    enderecoResult = input&#10;                                }&#10;&#10;                                if (isPreview) {&#10;                                    endereco = enderecoResult&#10;                                    feedbackMessage = &quot;Endereço encontrado com sucesso!&quot; to Color(0xFF006400)&#10;                                    return@launch&#10;                                }&#10;&#10;                                val geo: List&lt;Address&gt;? = withContext(Dispatchers.IO) {&#10;                                    try {&#10;                                        Geocoder(context).getFromLocationName(enderecoResult, 1)&#10;                                    } catch (e: IOException) {&#10;                                        Log.e(&quot;GEOCODER_ERROR&quot;, &quot;Erro no Geocoder: ${e.message}&quot;)&#10;                                        null&#10;                                    }&#10;                                }&#10;&#10;                                if (!geo.isNullOrEmpty()) {&#10;                                    val loc = geo[0]&#10;                                    val lat = loc.latitude&#10;                                    val lon = loc.longitude&#10;                                    val userPoint = GeoPoint(lat, lon)&#10;&#10;                                    mapView!!.controller.animateTo(userPoint)&#10;                                    mapView.overlays.clear()&#10;&#10;                                    // Salva localização do usuário&#10;                                    localizacaoUsuario = userPoint&#10;                                    &#10;                                    // Marcador com alfinete vermelho para o usuário&#10;                                    val userMarker = Marker(mapView)&#10;                                    userMarker.position = userPoint&#10;                                    userMarker.setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM)&#10;                                    userMarker.title = &quot; Você está aqui&quot;&#10;                                    userMarker.snippet = enderecoResult&#10;                                    userMarker.icon = criarIconeAlfinete(context)&#10;                                    mapView.overlays.add(userMarker)&#10;&#10;&#10;                                    val estabelecimentos = buscarMercadosProximos(lat, lon, raioKm = 5.0)&#10;                                    if (estabelecimentos.isNotEmpty()) {&#10;                                        Log.d(&quot;OVERPASS_DEBUG&quot;, &quot;${estabelecimentos.size} estabelecimentos encontrados&quot;)&#10;                                        &#10;&#10;                                        estabelecimentos.forEach { estab -&gt;&#10;                                            estab.distancia = calcularDistancia(&#10;                                                lat, lon,&#10;                                                estab.localizacao.latitude,&#10;                                                estab.localizacao.longitude&#10;                                            )&#10;                                        }&#10;                                        val estabelecimentosOrdenados = estabelecimentos.sortedBy { it.distancia }&#10;                                        estabelecimentosEncontrados = estabelecimentosOrdenados&#10;                                        &#10;                                        for (estab in estabelecimentosOrdenados) {&#10;                                            val markerEstab = Marker(mapView)&#10;                                            markerEstab.position = estab.localizacao&#10;                                            markerEstab.title = &quot;${estab.tipo}: ${estab.nome}&quot;&#10;                                            markerEstab.snippet = &quot;Distância: %.2f km&quot;.format(estab.distancia)&#10;                                            markerEstab.setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM)&#10;                                            markerEstab.icon = criarIconeCarrinho(context)&#10;                                            mapView.overlays.add(markerEstab)&#10;                                        }&#10;                                        feedbackMessage = &quot;${estabelecimentos.size} estabelecimentos encontrados!&quot; to Color(0xFF006400)&#10;                                    } else {&#10;                                        Log.d(&quot;OVERPASS_DEBUG&quot;, &quot;Nenhum estabelecimento encontrado nas proximidades.&quot;)&#10;                                        estabelecimentosEncontrados = emptyList()&#10;                                        feedbackMessage = &quot;Endereço encontrado, mas nenhum estabelecimento próximo.&quot; to Color(0xFFFFA500)&#10;                                    }&#10;&#10;                                    mapView.invalidate()&#10;                                    endereco = enderecoResult&#10;                                } else {&#10;                                    throw Exception(&quot;Endereço não localizado no mapa.&quot;)&#10;                                }&#10;&#10;                            } catch (e: Exception) {&#10;                                Log.e(&quot;SEARCH_ERROR&quot;, &quot;Falha na busca: ${e.message}&quot;, e)&#10;                                endereco = null&#10;                                feedbackMessage = &quot;Endereço não encontrado. Tente novamente.&quot; to Color.Red&#10;                            }&#10;                        }&#10;                    }) {&#10;                        Image(&#10;                            painter = painterResource(id = R.drawable.lupa_loc),&#10;                            contentDescription = &quot;Buscar&quot;,&#10;                            modifier = Modifier.size(24.dp)&#10;                        )&#10;                    }&#10;                    Image(&#10;                        painter = painterResource(id = R.drawable.microfone_loc),&#10;                        contentDescription = &quot;Microfone&quot;,&#10;                        modifier = Modifier.size(24.dp)&#10;                    )&#10;                }&#10;&#10;                feedbackMessage?.let { (message, color) -&gt;&#10;                    Text(&#10;                        text = message,&#10;                        modifier = Modifier.padding(top = 8.dp),&#10;                        fontSize = 14.sp,&#10;                        color = color&#10;                    )&#10;                }&#10;                &#10;&#10;                if (estabelecimentosEncontrados.isNotEmpty()) {&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    Column(&#10;                        modifier = Modifier.fillMaxWidth(0.9f),&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        estabelecimentosEncontrados.forEach { estab -&gt;&#10;                            val interactionSource = remember { MutableInteractionSource() }&#10;                            val isHovered by interactionSource.collectIsHoveredAsState()&#10;                            val scale by animateFloatAsState(&#10;                                targetValue = if (isHovered) 1.05f else 1f,&#10;                                label = &quot;card_scale&quot;&#10;                            )&#10;                            &#10;                            // Animação de clique&#10;                            val clickScale = remember { Animatable(1f) }&#10;                            val coroutineScope = rememberCoroutineScope()&#10;                            &#10;                            Card(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .scale(scale * clickScale.value)&#10;                                    .clickable(interactionSource = interactionSource, indication = null) {&#10;                                        coroutineScope.launch {&#10;                                            // Animação de &quot;pulse&quot; ao clicar&#10;                                            clickScale.animateTo(&#10;                                                targetValue = 0.95f,&#10;                                                animationSpec = tween(durationMillis = 100)&#10;                                            )&#10;                                            clickScale.animateTo(&#10;                                                targetValue = 1.05f,&#10;                                                animationSpec = tween(durationMillis = 100)&#10;                                            )&#10;                                            clickScale.animateTo(&#10;                                                targetValue = 1f,&#10;                                                animationSpec = tween(durationMillis = 100)&#10;                                            )&#10;                                            // Abre o modal após a animação&#10;                                            estabelecimentoSelecionado = estab&#10;                                        }&#10;                                    },&#10;                                shape = RoundedCornerShape(12.dp),&#10;                                colors = CardDefaults.cardColors(containerColor = Color.White),&#10;                                elevation = CardDefaults.cardElevation(4.dp)&#10;                            ) {&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(12.dp)&#10;                                ) {&#10;                                    Row(&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        // Foto do estabelecimento&#10;                                        AsyncImage(&#10;                                            model = ImageRequest.Builder(LocalContext.current)&#10;                                                .data(estab.photoUrl)&#10;                                                .crossfade(true)&#10;                                                .build(),&#10;                                            contentDescription = &quot;Foto de ${estab.nome}&quot;,&#10;                                            modifier = Modifier&#10;                                                .size(60.dp)&#10;                                                .background(Color(0xFFE0E0E0), RoundedCornerShape(8.dp)),&#10;                                            contentScale = ContentScale.Crop&#10;                                        )&#10;                                        &#10;                                        Spacer(modifier = Modifier.width(12.dp))&#10;                                        &#10;                                        Column(modifier = Modifier.weight(1f)) {&#10;                                            Text(&#10;                                                text = estab.nome,&#10;                                                fontSize = 14.sp,&#10;                                                color = Color.Black,&#10;                                                maxLines = 1,&#10;                                                style = TextStyle(fontWeight = FontWeight.Bold)&#10;                                            )&#10;                                            Text(&#10;                                                text = estab.tipo,&#10;                                                fontSize = 12.sp,&#10;                                                color = Color.Gray&#10;                                            )&#10;&#10;                                            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                                                repeat(5) { index -&gt;&#10;                                                    Text(&#10;                                                        text = if (index &lt; estab.rating.toInt()) &quot;⭐&quot; else &quot;☆&quot;,&#10;                                                        fontSize = 10.sp,&#10;                                                        color = if (index &lt; estab.rating.toInt()) Color(0xFFFFC107) else Color.Gray&#10;                                                    )&#10;                                                }&#10;                                                Text(&#10;                                                    text = &quot; %.1f&quot;.format(estab.rating),&#10;                                                    fontSize = 11.sp,&#10;                                                    color = Color.Gray&#10;                                                )&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                    &#10;&#10;                                    if (estab.comentarios.isNotEmpty()) {&#10;                                        Spacer(modifier = Modifier.height(8.dp))&#10;                                        Card(&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            colors = CardDefaults.cardColors(containerColor = Color(0xFFF5F5F5)),&#10;                                            shape = RoundedCornerShape(8.dp)&#10;                                        ) {&#10;                                            Column(modifier = Modifier.padding(8.dp)) {&#10;                                                Text(&#10;                                                    text = &quot; Comentários:&quot;,&#10;                                                    fontSize = 11.sp,&#10;                                                    color = Color.Gray,&#10;                                                    style = TextStyle(fontWeight = FontWeight.Bold)&#10;                                                )&#10;                                                Spacer(modifier = Modifier.height(4.dp))&#10;                                                estab.comentarios.take(2).forEach { comentario -&gt;&#10;                                                    Text(&#10;                                                        text = &quot;• $comentario&quot;,&#10;                                                        fontSize = 11.sp,&#10;                                                        color = Color.DarkGray,&#10;                                                        maxLines = 1&#10;                                                    )&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                }&#10;                }&#10;            }&#10;        }&#10;        } // Fecha o Box principal&#10;&#10;&#10;        estabelecimentoSelecionado?.let { estab -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.Black.copy(alpha = 0.5f))&#10;                .clickable { estabelecimentoSelecionado = null },&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth(0.9f)&#10;                    .padding(16.dp)&#10;                    .clickable(enabled = false) { },&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(containerColor = Color.White),&#10;                elevation = CardDefaults.cardElevation(8.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .padding(16.dp)&#10;                ) {&#10;&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = estab.tipo,&#10;                            fontSize = 14.sp,&#10;                            color = Color.Gray&#10;                        )&#10;                        IconButton(onClick = { estabelecimentoSelecionado = null }) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Close,&#10;                                contentDescription = &quot;Fechar&quot;,&#10;                                tint = Color.Gray&#10;                            )&#10;                        }&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    &#10;&#10;                    if (estab.photoUrl.isNotEmpty()) {&#10;                        AsyncImage(&#10;                            model = ImageRequest.Builder(LocalContext.current)&#10;                                .data(estab.photoUrl)&#10;                                .crossfade(true)&#10;                                .build(),&#10;                            contentDescription = &quot;Foto de ${estab.nome}&quot;,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(180.dp)&#10;                                .background(Color(0xFFE0E0E0), RoundedCornerShape(12.dp)),&#10;                            contentScale = ContentScale.Crop&#10;                        )&#10;                    } else {&#10;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(180.dp)&#10;                                .background(Color(0xFFE0E0E0), RoundedCornerShape(12.dp)),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            val emoji = when (estab.tipo) {&#10;                                &quot;Supermercado&quot; -&gt; &quot;&quot;&#10;                                &quot;Mercado&quot; -&gt; &quot;&quot;&#10;                                &quot;Mercearia&quot; -&gt; &quot;&quot;&#10;                                else -&gt; &quot;&quot;&#10;                            }&#10;                            Text(&#10;                                text = emoji,&#10;                                fontSize = 80.sp&#10;                            )&#10;                        }&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    &#10;                    // Nome do estabelecimento&#10;                    Text(&#10;                        text = estab.nome,&#10;                        fontSize = 20.sp,&#10;                        color = Color.Black&#10;                    )&#10;                    &#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    &#10;                    // Avaliação&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        repeat(5) { index -&gt;&#10;                            Icon(&#10;                                imageVector = Icons.Default.Star,&#10;                                contentDescription = &quot;Estrela&quot;,&#10;                                tint = if (index &lt; estab.rating) Color(0xFFFFC107) else Color(0xFFE0E0E0),&#10;                                modifier = Modifier.size(20.dp)&#10;                            )&#10;                        }&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(&#10;                            text = &quot;%.1f&quot;.format(estab.rating),&#10;                            fontSize = 16.sp,&#10;                            color = Color.Black,&#10;                            style = TextStyle(fontWeight = FontWeight.Bold)&#10;                        )&#10;                        Text(&#10;                            text = &quot; (${estab.totalReviews} avaliações)&quot;,&#10;                            fontSize = 13.sp,&#10;                            color = Color.Gray&#10;                        )&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    &#10;                    // Endereço Completo&#10;                    Row(&#10;                        verticalAlignment = Alignment.Top&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;&quot;,&#10;                            fontSize = 20.sp,&#10;                            modifier = Modifier.padding(end = 8.dp)&#10;                        )&#10;                        Column {&#10;                            Text(&#10;                                text = &quot;Endereço Completo&quot;,&#10;                                fontSize = 12.sp,&#10;                                color = Color.Gray&#10;                            )&#10;                            Text(&#10;                                text = &quot;${estab.endereco}, ${estab.numero}&quot;,&#10;                                fontSize = 14.sp,&#10;                                color = Color.Black,&#10;                                style = TextStyle(fontWeight = FontWeight.Bold)&#10;                            )&#10;                            Text(&#10;                                text = estab.bairro,&#10;                                fontSize = 13.sp,&#10;                                color = Color.DarkGray&#10;                            )&#10;                        }&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(12.dp))&#10;                    &#10;                    // Distância&#10;                    Row(&#10;                        verticalAlignment = Alignment.Top&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;&quot;,&#10;                            fontSize = 20.sp,&#10;                            modifier = Modifier.padding(end = 8.dp)&#10;                        )&#10;                        Column {&#10;                            Text(&#10;                                text = &quot;Distância&quot;,&#10;                                fontSize = 12.sp,&#10;                                color = Color.Gray&#10;                            )&#10;                            Text(&#10;                                text = &quot;%.2f km de você&quot;.format(estab.distancia),&#10;                                fontSize = 14.sp,&#10;                                color = Color(0xFFF9A01B)&#10;                            )&#10;                        }&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    &#10;                    // Botão de ação&#10;                    Button(&#10;                        onClick = {  },&#10;                        modifier = Modifier&#10;                            .fillMaxWidth(),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFFF9A01B)&#10;                        )&#10;                    ) {&#10;                        Text(&quot;Ver no Mapa&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        } // Fecha o estabelecimentoSelecionado?.let&#10;    } // Fecha o Box externo&#10;} // Fecha a função TelaLocalizacao&#10;&#10;&#10;// Preview da tela de localização&#10;@Preview(showSystemUi = true)&#10;@Composable&#10;fun TelaLocalizacaoPreview() {&#10;    InfoHub_telasTheme {&#10;        TelaLocalizacao(rememberNavController())&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>